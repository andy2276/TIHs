TIH기능설계
==============
계층적인 구조로 되어있는 기능 설계
-----------------------
# 설계에 앞서서
어느한 고수의 이야기
- 레퍼런스는 캐시메모리의 캐싱 효과를 볼 수 없다.
	- 그래서 파라미터로 잘 보내지 않는다.
		- 멀티코어 프로그래밍에서는 특히 잘 사용하지 않는다.
		- 최신하드웨어를 사용할 수 없기에 복사기능을 더 많이 사용한다.
			- 다시 메모리를 읽는 것은 성능이 좋지않다.
- Exception 을 사용하지 않는다
	- cpu 의 Exception 은 gpu 단에 데이터를 보낼 방법이 없다.
- 다형성과 다중상속을 사용하지 않는다.
	- 유지 보수단계에서 해당 코드를 다시 활용할 수 없다.
	- 스파게티 코드가 만들어진다.
- 자주 사용하는 멤버변수는 근처에 배치
	- 캐시라인 최적화이다.
- 메모리 패딩
___
**하지만** 디자인 패턴은 알고있는 사람들로 하여금 생산성과 유지보수성을 늘려준다.<br>
이 부분에서는 성능을 포기하는게 맞는데, 빈도수로 생각해보면 **즉  시간복잡도로 생각해보면**이러한 부분을 나눠서<br>
만들게 된다면 어느정도 성능과 생산,유지보수성을 지킬 수 있을 것이다.
## 항상 생각할것
+ 성능(Performance)
	+ 최적화를 해야한다라는 말이다. virtualTable,LookUpTable 같은걸 적절하게 활용해야하며 이로인해 성능은 올라간다
+ 유지보수(Maintainability)
	+ 코드의 가독성을 높인다는 말이다. 
	뿐만아니라 확장성을 포함하기때문에 기능추가에 열려있어야한다. 
	프로젝트 관리또한 포함이 된다
+ 생산성( Productivity )
	+ 코드를 효율적으로 짜는 것을 말한다. 효율에 상속이 포함될 수 있는데, 유지보수성을 올리다보면 생산성은 떨어지기때문에 핵심키워드까지는 아니다. 
	툴 사용이 핵심적이다.
+ 가용성( Availability )
	+ 유저가 원하는대로 기능이 작동해야하는 것이다.
	+ 신뢰성과의 차이점이라면 유저가 요구하는대로 사용이 될 수 있다는 것이 핵심이다. 
+ 신뢰성( Reliability )
	+ 안정적인 코드의 실행을 뜻한다.
	+ 버그를 발생하는 것은 신뢰성에 문제를 일으키며 랜덤으로 작동하는 것또한 신뢰성에 문제가 생긴다.
	+ 그래서 신뢰성 있는 코드를 위해서는 많은 예외케이스를 두어야한다
+ 안전성( Safety )
	+ 안전성은 약간 도덕의 영역인데, 유저가 리스크를 질 수 있는 코드를 작성하면 안된다는것이다.
	+ 예를 들자면 printf 같은 것이있다. 시스템이나 유저에게 문제를 일으킬 만한 코드는 주의해야한다는 것이다.
+ 보안성( Security )
	+ 안전성과 비슷하지만 핵심적인 차이는 외부의 공격유무에 있다.
	+ 보안성은 암호화나 코드 유출같은것을 막을만한 행동을 말한다.
+ 호환성( Compatibility )
	+ 다른 os 나 그런곳에 호환되는 것을 말한다. 
+ 사용성( Usability )
	+ 유저가 사용하는데 쉽게 알수있는 것을 말한다.
+ 지역화( Localization )
	+ 다양한 지역에서 사용될수있게 하는것을 말한다.
	
+ 해당 부분은 코드를 작성할때 꼭 고려해야하는 것들로

> 성능이 좋지않아서 60FPS 이하로 나오지 않도록 최적화 해야한다.

> 유지보수성이 좋지않아서 프로그래머가 확장할때 이전의 코드를 변경하거나 새롭게 만들지 말아야하며,<br>이해하는데 시간이 적게들어야한다

> 생산성이 좋지않아서 프로젝트가 밀리지 말아야한다.

> 가용성이 부족하여 유저의 요청을 미루면 안된다.

> 안전성이 부족하여 유저의 컴퓨터가 멈추거나 작동이 불가능하면 안된다.

> 보안성이 좋지않아서 유저의 정보가 유출되거나 해킹을 당해서는 안된다.

> 호환성이 나빠서 다른 디바이스나 os 이식이 불가능하면 안된다.

> 사용성이 부족하여 유저가 불편해 하면 안된다.

> 지역화가 안되어있어서 다른 나라의 유저가 접근하기 힘들어서도 안된다.

+ 간단하게 만들어야한다. 만들고 추가하고 그걸 기록해야한다. 기록은 무조건 용도로

## 정보
언리얼에서 와인딩 오더를 triangles 라고 부른다. 
언리얼에서 replicate 플래그는 서버로 데이터를 보낸다는 것이다. 

## 주의점
무조건 양수영역에서물체를 배치한다. 
## 사용되어진 기술
obb Tree
3d picking - 이거는 음... 이걸 하려고 하는 이유가 뭔가? 
	가장 큰 이유는 성능이다. 물체가 많아질것이고, 물체도 좀 고사양일텐데 그걸 그냥 했다가는 분명히 성능이 느려질것이다,
		그래서 우선은 물체들의 충돌을 꺼놓고 그냥 랜더만 돌리는 생각을 한것인데, 피킹을 하려면 물체의 콜리전이 있어야한다.
		물체의 콜리전박스가 있어야 속도가 나오는데, 마우스 레이힛 물체 정보 리턴 이렇게 되려면 모든 바운딩 박스가 켜져있어야한다.
		이러면 느려진다. 무조건 느려진다. 
		커스텀 콜리전 함수를 만들 수 잇을것이다. 암튼 그럴거야. 시발
			그러면 선택을 위한 바운드, 물체를 배치하기 위한 레이어로 나누자.
			그럼 레이어는 어떤 기능이 있어야하는가?
			일단 물체의 수직 벡터들위에 자동으로 배치 영역을 만드는게 필요하다.
				물체끼리 충돌이 일어난다라는것을 기준으로 해야한다. 
				레이어가 나누어 지게 만들자. 그럼 레이어는 표면의 각도에 따라 만들어져야한다.
					이러한 것은 유저가 물체를 올리고 특정 버튼을 누르면 생성되게 만들어야한다.
				면충돌을 그냥 레이어에서 만들까? 바운딩 박스를 만들수 있나?
				내비메쉬 만드는 것처럼 BFS 로 만들어야할거 같다. 그런데 조건이 수직인것들만 뭉치고 이미 찾은 영역에대해서는 더이상 탐색하지 않는식으로 진행해야한다.
auto collision
	인덱스 버퍼와 버텍스버퍼를 가져온다.
	
# 공통기능 
플레이어 컨트롤에서 hit 을 해주고 그 hit 을 했을때 오브젝트에게 호출을 해준다.
1110 에해야할것
houseUserPawn 을 만들어야한다
	해당 pawn 은 공통의 pawn 인데, 마우스가 움직일때 확인해야할 이벤트들은 observer에서 호출해준다. 이게 인풋
	이렇게 인풋이 되면 이제 처리를 어디서 하는가. 근데 물체 존나 많아 질텐데 어떻게하냐...일단은 만들고 나서 최적화하자. 그럴려면 최대한 인아웃으로 만들어야한다.
	시스템부분 에서는 c++ 네이티브라고 생각하고 코딩하고,
		만약 인터미디어 해야한다하면 흠...성능부분을 따로 빼야하는데, 이게 콜리전 혹은 피킹이 그런거일거란 말이지
			왜냐하면 마우스에 물체를 올린다고 생각하자. 마우스가 있는 영역은 내 부지 안일것이고, 그 안에 있으면 충돌을 일으켜야하는데, 같은 레이어에서 충돌은 일단 마우스가 해당 레이어 위에 있는지 확인하고 그 레이어 안에 있는데 마우스를 움직인다면 계속해서 레이어 체크만. 레이어 체크는 해당 물체의 콜리전과 중심점으로 확인이 가능 그건 속도가 빠를거임. 그럼 결국 레이어는 obb 를 적용하긴 해야한다는 것이다. 그럼 충돌했을때 나가면 안되는 물체가
				다시 생각해보자면 마우스 포인트 혹은 들고있는 물체의 중심점이 어느레이어에 있는지 계속 확인
				아! 레이어와 물체 바운드 혹은 물체의 콜리전을 서로 나누자. 레이어는 물체를 배치할때 작동한다. 2차원으로 투영되어진 영역에 마우스 포인트(클릭한 물체가 시작점. 그래봤자 움직여도 많이 움직이지 않는다.만약 옆으로 움직였다 하면 전체 레이어맵에서 해당 영역만 불러오고 해당 영역안에 있는 물체들만 충돌체크!)
				레이어 충돌은 물체를 피킹후 즉 물체가 마우스에 올라가 있을때만
				바운드 충돌은 나중에 상호작용 혹은 마우스 피킹시에만 사용한다. 
			즉 마우스 충돌 모드에는 2가지가 존재하고, 그 2가지는 서로 겹치지 않는다.
	이제 레이어를 어떻게 계산해서 넣어줄지.
		우선은 레이어 맵을 만들어서 사용하자.
			그럼 아 시발 알았다. 전사시킨다. 
			즉 전체 버텍스들의 노말을 혹은 폴리곤 노말을 퀄리티에따라 기본은 256 ㅌ 256으로 하고 해당 영역에 깊이를 측정한다. 
			이거는 카메라 혹은 gpu 단에서 해줘도 상관없을것같음. 
			물론 처음에는 이걸 공통함수로 묶어서 나중에 변경할수 있게 만들자. 즉 strategy 패턴을 사용해서 해당 물체의 탑뷰에서 투영시키는걸 생각하자. 버텍스가 바운드 안에 없다면 
# 하우징

## 하우징 노드들이 가져야할 내용들
- 연결되어진 액터(bridgePattern)
	+ 여기로 데이터들을 전송하여 만들것이다. 즉 바로 생산으로 가는게 아니다
		+ 여기서 커맨드 노드가 필요하다
		+ 또한 해당 데이터를 적재할 공간이 필요하다
			+ 공통으로 사용되는 데이터들에 대한 형태를 descriptor 를 만들자
				+ descriptor 는 해당 데이터에 대한 명세서 같은것이다.
					+ 즉 resource 와 descriptor 는 서로 다르며 resoruce 는 그저 데이터덩어리다
					+ 
- 레이어 {이거는 솔직히 말하자면 모든 하우징 노드들이 가져야할것이다.} 단일 final
	+ 성능을 위해서 단일로 만든것이다.
		+ 레이어들끼리 묶어서 obb 계산을 하는 함수가 있어야한다.
			+ 모든 obb 혹은 레이어
		+ 물체들에 대한 명세서 목록을 어디선가 가지고있게 한다.
			+ 싱글톤을 사용할지 아니면 const 로 들고올지는 생각해보자.
## 마우스 클릭
특정 오브젝트를 선택하는 것은 사실 rayTracing 의 일종이다. 
	인풋 바인딩 : 해당부분은 새로운 input 바인딩 시스템으로 변경이 가능하다. 왜냐하면 어떤 행동에 어떤 기능이 달린지만 넣으면되는데 여기서는 마우스 클릭이다.
		레거시 : project Settings -> Input -> Bindings -> Action Mapping 에서 마우스 클릭에 관한 내용을 바인딩해준다
	인풋 c++ 바인딩
		SetupPlayerInputComponent를 상속받은 pawn 에서 해준다.
		playerInputComponent->BindAction() 으로 바인딩 하는데, 함수 포인터를 사용해서 넣는다.
	플레이어 컨트롤
## 부지선택기능
- 새로운 부지 만들기
	+ 레이어위에 물체를 올린다는 개념으로 접근한다
		+ 그럼 어떤 물체든 레이어를 가질 수 있다라고 생각해야한다.
			+ 그러한 레이어는 또 나뉘어서 트리구조로 되어있어서 obb Tree 식으로 선택할 수 있다.
				+ 레이어 피킹은 반직선을 사용할까? ㅋㅋㅋ이것도 이론을 찾아보자.
					+ 그럼 피킹은 어디서 작동을 해줘야 할까? 
	+ 새로운 부지의 썸네일을 가지고 있는 녀석이 있어야한다.
		+ 모든 노드들은 썸네일과 빌드를 가지고 있어야한다.
			+ 왜냐하면 썸네일을 클릭할 것이기때문이기도 하고 그렇다
	+ 그렇다면 부지노드에게 필요한것은
		+ 썸네일 
			+ 함수
				+ 썸네일은 캡처
				+ 썸네일 가져오기
				+ 썸네일 준비를 위한 데이터 넣기
			+ 데이터
				+ 썸네일은 이미지를 메모리에 올려놨는지
				+ 썸네일이 저장되어야 할 위치
					+ 원격 GlobalPath
					+ 지역 LocalPath
				+ 썸네일 이미지 데이터
			+ 메타데이터 : 메타데이터만 보고도 데이터를 불러올 수 있어야한다. 
				+ 타입 : 부지,층,물건,사람,친구 등...
				+ 저장일시 : 년일월시분초
				+ 버전 : 0.0.0 에서 시작 데이터의 변화가 많아지거나 시간이 많이 올라가면 변화(저장에 따른 변화는 맨뒤)
				+ 저장크기 : 32bit
				+ 화소 : width x height
				+ 현저장위치 : 로컬인지 원격인지는 중요한게 아님 그냥 저장되어있음. 저장위치의 변화는 사용성에 달려있다. 지금 사용하고 있다면 로컬일것이고 아니면 원격일것이다. 원격으로 저장하는 이유는 멀티를 위해서임
				+ 소유자 : 최초의 유저
				+ 해쉬 : 화소와 타입 그리고 소유자와 처음 저장일시로 해쉬를 만든다.
					+ 그러므로 해쉬를 만들어주는 함수도 필요하다.
				+ 설명 : 기타 설명을 기입하게 만들어야한다.
		+ 링크되어진 UE액터
			+ 해당 클래스는 기본적으로 언리얼 엔진에서 표현되기 위한 것이다.
			<br> 일방적인 통신은 아니고 서로 통신은 하지만 명령을 받는 peer 로써 주로 사용이되며, 생산하는 곳또한 특정 시스템에 의해 생산되며 내부에 표현을 위한 정보이외에는 가지고 있지 않다.
			<br>물론 변화가 일어나면 업데이트를 해야할것이다.
			+ 함수
				+ 콜리전 obb
				+ 콜리전 마우스 픽 : 이거는 무조건 위에 있는 레이어가 먼저 선택이 될것이라는 걸 전제로 한다
				+ 변화 업데이트 : 이거는 커맨더로 넘기는것이다.
					+ 여러버전이 있을것으로 보인다
			+ 데이터
				+ 부지노드 혹은 베이스판 노드
			+ 메타데이터
				+ 테그
		+ 레이어
			영역밖에 있으면 빨간색이고 물체의 크기는 기본으로한다. 그리고 물체는 해당 기본크기로
			+ 함수
				+ 예정 혹은 테스트를 봐야하는것
					+ 캡처
					+ 충돌 :정점이 해당 영역안에 있는가
						+ 근데 생각해보면 한점이 해당 영역안에 있는가를 고속으로 검색하는 방법은 자신을 포함해서 자신위에만 있는 것을 선택하게 하면 되는거아닌가? 음...
				+ 겟 레이어 높이
					+ 해당 기능이 물체가 배치되어질 높이를 뜻하는것이다.
				+ 겟 레이어 월드 xy 영역 
					+ 해당 기능이 물체가 어떤 물체에 갔을때 
			+ 데이터
				+ 
			+ 메타데이터 : 근데 이것도 저장해야하나...흠..
				+ 타입 : 부지,층,물건,사람,친구 등...
				+ 저장일시 : 년일월시분초
				+ 버전 : 0.0.0 에서 시작 데이터의 변화가 많아지거나 시간이 많이 올라가면 변화(저장에 따른 변화는 맨뒤)
				+ 저장크기 : 32bit
				+ 화소 : width x height
				+ 현저장위치 : 로컬인지 원격인지는 중요한게 아님 그냥 저장되어있음. 저장위치의 변화는 사용성에 달려있다. 지금 사용하고 있다면 로컬일것이고 아니면 원격일것이다. 원격으로 저장하는 이유는 멀티를 위해서임
				+ 소유자 : 최초의 유저
				+ 해쉬 : 화소와 타입 그리고 소유자와 처음 저장일시로 해쉬를 만든다.
					+ 그러므로 해쉬를 만들어주는 함수도 필요하다.
				+ 설명 : 기타 설명을 기입하게 만들어야한다.
- 부지 이동
	+ 연결되어진 것은 위젯이다. 즉 모든 링크 ue액터가 같은건아니다. 
	+ 로딩기능이 제대로 되어있어야한다
## 층선택 기능
	- 

## 물건을 놓는기능
	- 물건 썸네일
		+ 그말은 지금 유저가 선택할 수 있는 물체들이 트리구조로 되어있고, 그러한 구조에서 불러오는 방법을 사용해야한다
			+ 전체 트리구조에서 해당 유저가 가져올 수 있는 목록을 db에저장
				+ 음
				

# 스트리밍

## 외부 트래킹

## 오토 리타겟팅

## 텍스쳐 익스포트

# 스테이션

## 유저 정보 입력

## 서버 연결 기능 업그레이드

# 정해진것

## 하우스 노드
썸네일
레이어
	2차원으로 만들어진 공간

레이어에서 썸네일을 드래그 해서 썸네일들이 있는 공간을 벗어났을 경우 이제 물체를 랜더해서 만든다.
 해당 클래스느 뭐 따로 있겠지. 
 하여튼 이렇게 만들어진 물체는 만약 마우스의 포인터가 허용되지 않은 영역 혹은 그러한 토글이 이루어지지 않았는지 검사를 계쏙한다. 검사계속 이렇게 영역밖에 있을 경우 물체는 카메라의 뷰의 일정크기로만 존재한다. 
 혹은 썸네일의 크기만큼 혹은 그보다 조금 더 커진 상태로만 존재하게 한다. 
 마우스 포인터에 달려있는 물체는 인터미디어로써 존재하게한다.
 하여튼 마우스 포인터가 특정 위에 올라갔을경우 그니깐 마우스는 정상적인 충돌이 이루어진것임.
 이렇게 이루어진 정상적 충돌이 일어난 물체의 z 나 정보를 불러와 마우스의 포인터도 강제로 이동시켜서 물체를 올려놓는다.
 강제로 이동하는 위치는 마우스의 위치에 비례해서 멀었을경우 해당 방향의 최대 치에 해당하는 벡터로 구해서 위치시킨다
 그럼 유저가 물체를 이동할때 지금의 포인터를 위치했다로 바꿔준다.
 위치했다로 바뀌어진 물체는 
 그럼 썸네일 클래스를 먼저만들자.
 그리고 연결
 마우스 인터미디어 함수도 만들자
 그럼 물체를 먼저만드러야한다.
그럼 썸네일 함수가 먼저겠네
썸네일 함수가 전부겠네

UMG 에디터를 사용하려면 블루프린트화 시켜야한다
	그러므로 무조건 필요한 것들은 포인터화 시켜서 내부에 저장하게 하고 계층만 다르게 만들면 될거같다.

# 규칙
## 변수 규칙
+ 위치+타입+명사
	+ 위치
		+ m : 맴버변수일때
		+ g : static 혹은 글로벌 변수일때
	+ 타입
		+ Container
		+ UI
	+ 명사
		+ 단수
		+ 복수
## 클래스 이름 규칙
+ TIH
	+ pakName
	+ 공통의 기능일 경우 제외
		+ Signature
			+ 공통역할(ex : controller,UI...)
				+ Controller : 키인풋을 받는 객체. 핵심 역할이 없다면 공용으로 사용
				+ UI : 공용으로 사용되는 UI 뒤에 특수한것이 붙는다.
				+ Prompter : 디스플레이를 컨트롤 하는 시스템에 적용되는것.
+ Bluprint
	+ 맨뒤에 Bp 를 박는다
+ 맨뒤에 processor 가 들어갈경우
	+ 이 경우에는 
	
		
# 액터 - 노드트리

## 액터
+ 인터렉션을 담당하는 부분이다.

## 노드
+ 액터가 가지는 정보는 내부분 노드가 가진다.
+ 에라이 시팔 모든건 uobject 를 통한다

해야할일
station 기초만들기
housePak 에다가 마우스 포인터 클래스 만들기
	마우스 포인터 클래스를 어디다가 놓을지 생각
		하우스 폰에다가 controller binding 만들기
		하우스 빌드 폰을 만들기
	umg 만들기
	
	
	
TIHHouseBuildController
	빌드에 필요한 컨트롤러 이다. 
TIHHouseBuildMousePointer
	빌드에 필요한 마우스 포인터에 대한 정보를 담고있다
	내부에 기능으로는 지금 클릭 되어있는 물체에 대한 정보.
	지금 마우스 클릭의 상태
TIHHouseBuildPromptUI
	프롬프트 ui 이다. 밑에 올라오는 ui 이다
*TIHHouseBuildPromptTumnailUI
	프롬프트 ui 에서 build 를 위한 Thumnialui 를 말한다
TIHHouseThumnail
	썸네일에 대한 이미지라든지 기능을 담고있다.
TIHHouseNode
	네이티브로 만들어진 노드 계층구조이다. 
	물체에 대한 정보를 담고있다. 
	자신의 하위 물체들에 대한 정보도 담고있다.
	컴포넌트 패턴이다. 
*TIHHouseLayer
	설치가 가능한 영역에 대한 클래스이다. 
	네이티브로 만들어짐
	영역을 표시하는건 다른곳에서 하고 리프노드는 레이어를 여러개 가질 수 있음.
	레이어를 만드는건 다른문제
		레이어 충돌에 대한 내용은 나중에 생각하고 
		레이어는 다각형2차원이다.
		여러개를 가질 수 있고, 여러개는 리프가 담고있을것이다.
		
TIHHouseLeaf
	실제의 물체 정보를 담고있다. 
		static 물체인가
		skeletal 물체인가
		light 물체인가
		복합적인 물체인가
		
		물체의 상대적 위치는 어디인가(transform)
	물체의 컨텐츠 위치에 대한 정보를 담고있다.
		컨텐츠가 서버인가 로컬인가
	물체의 용량은?
	물체의 이름은?
	물체의 
TIHHouseComposite
	레이어를 가지고있다. 
	물체들에 대한 정보를 담고있다.
		물체들은 몇개인가
		
	폴더역할을 하면서 물체를 필터하는 역할을 한다.
	필터가 레이어이며, 영역
	그냥 합치자 노드는 레이어를 가지고, 물체도 가지고, 자식들도 가질것이다.
	
TIHHouseStuff
TIHHouseLayerLinker

000000000111111111122222222223
123456789012345678901234567890

마지막에 있는 것은 줄이지말자.
	주요한 기능은 intellisence 검색에 사용하기 위해서 줄이는것이라는것이다.
together in hear : TIH  
TIH - together
HouBui - HouseBuild 
	house - house
	build - build
HouNod - HouseNode
Thmb - Thumnail
Proc - Process or processor
Ctrl - Control
App - Application
Config - Configuration
Auth - Authentication
Info - Information
Lib - Library
Temp - Temporary
Msg - Message
Params - Parameters
Admin - Administrator
Init - Initialize/Initialization
Func - Function
Arg - Argument
Num - Number
Val - Value
Calc - Calculate/Calculation
Sys - System
Util - Utility
Doc - Document
Env - Environment
Lang - Language
Max/Min - Maximum/Minimum
Img - Image
Txt - Text
Lnk - Linker or Link
         1         2         3
123456789012345678901234567890
TIHHouseBuildThumnailPrompterItemUI
			 1         2         3
	123456789012345678901234567890
				 1         2         3	
		123456789012345678901234567890
					 1         2         3		
			123456789012345678901234567890
						 1         2         3			
				123456789012345678901234567890
ATIHHousingPakProcessor
	ATIHHousePawn
		FTIHHouseController
	ATIHHouseBuildPawn : TIHHousePawn
		FTIHHouBuiController : TIHHouseController
			FTIHHouseBuildMouse
	TIHHouseUIProcessor
		TIHHousePrompter
		
		TIHHouseBuildPrompter : TIHHousePrompter
			TIHHouseBuildThmbUI
				TIHHouseBuildThmbSlotUI
	TIHHouseStuffProcessor
		TIHHouseStuff
			TIHHouseNodeLinkComponent
			

TIHHousePawn
	TIHHouseController
TIHHouseBuildPawn
TIHHouseBuildController
	TIHHouseBuildMousePointer
TIHHouseBuildPromptUI
	
Async 의 종류
AsyncFrameTick
	핵심으로는 한작업이 큰작업이면 안된다. 한스탭 작동이라고 생각. 혹은 무거운 작업을 여러 프레임에 나눠서 작업한다고 생각
AsyncBackgroundTask
	무거운 작업에 사용이되지만 서로 영향이 없는 독립적인것에만 사용을 해야한다.
AsyncWorkWait
	서버로 데이터를 넘기고 서버에서 데이터를 처리한 결과를 기다리는데 사용이 된다. 언리얼의 타이머를 사용한다. 주기적으로 확인하는 용도라 좀 느릴거임.
	테스트시 : 그냥 함수 호출시 바로 호출한다.
AsyncSubChain
	특정 작업이 끝났을때 호출된다. 이는 특수한 옵션으로써 커맨드 리스트자체가 chain 이지만 거기서 다른 subChain 인것이다.
	
CommandChain
	파사드 패턴으로 가자.
		class chain
			host
			func
			argu
			opt
			state
			
왜 커맨드 리스트형태를 만들려고하는가
	흐름의 시각화
	tick base Acync 구현
	함수형 프로그램을 위한 절차적 readWrite
	디버그를 위한 코드 일반화
	고려사항
		성능
			문제 오버헤드
				분명히 커맨드 리스트를 작성하는 것과, 커맨드 리스트가 참조할 영역에서 메모리와 성능 낭비가 일어날것이다.
			해결책
				해당 문제에 대해서 유지보수성과 성능을 생각했을때 자주 실행되지 않고 커다란 구조에 대해서만 이러한 내용을 적용하게 된다면
				사실상 문제가 되지 않을 것 같다. 
				서버 연결이나 데이터 메인 시스템의 write 는 중요한 작업이기때문에 반드시 trace 가되어야한다.
			문제 순차적 실행
				아무리 Acync 를 구현했다 하더라도 백그라운드에서 작동하는게 필요한데 아예 멈춰서서 싱글쓰레드로 작동하는것이 문제
				처럼 보일것이다.
			해결책
				하지만 서버 연결이나 순차적으로 반드시 선행이 되어야하는 작업의 경우에 그에 해당하는 흐름을 chain 으로 만들 수 있고,
				그렇게 만든 chain 은 하나의 거대한 프로그램처럼 상태를 저장하고 재실행이 이루어진다.
				이렇게 만들어지면 또 다른 장점이 단점보다 크고, 만약 이렇게 다르게 작업해야하는게 있었다면 즉 이전의 작업이 크게 영향을 받는 것이 아니었다면
				그냥 이전처럼 프로그램하거나 해당 구조에서 AcyncBackgroundTask 로 명령을 내리고 다음 커맨드로 넘어가면 문제 될게 없다.
			재기획
				생각해보니깐 그냥 하면 된다. 예를들어 순차적으로 기다려야한다면 사실 FrameTick 을 해도되는데 명시하기 위해서 음...이거랑 wait 이랑 무슨차이지? 틱은 한번 지나가고 다시 스스로를 큐에 넣는다라고 생각을 하자.

노드
	노드는 생성구조로써 복잡한 것을 만들어주는 것이다. 대표적인 예로는 FBX 가 있다. 
	생성구조이면서 데이터를 저장하는 공간이면서 성능을 위해 존재하는 곳이다. 물론 이를 분리해도 괜찮다.
				
게임실행
	station 생성
		필요한 서버에 연결.
		커맨드 리스트 초기화
	stationInit
		지금 처음의 pak 을 실행(일단은 buildPak)
		//pakPrepare : 이벤트 체인을 실행하기 전에 해당 팩을 준비하는 곳 혹은 그냥 바로 event chain 을 실행?
		NextCommand(CommandChain(HousePakInitEventChainList))()
			prepare(ServerWait)
				!서버연결 요청('houseBuild','houseThumb','houseDB')
					유저의 하우스 빌드 db 를 들고온다
						하우스 빌드 db 를 들고 왔는가?
					유저의 썸네일을 들고온다.
						썸네일 정보를 들고왔는가?(원격 && 로컬(호스트일경우만))
					유저의 하우스 db 를 들고온다.
						하우스 db 를 들고 왔는가?(원격 && 로컬(호스트일경우만))
				
					해당 내용들이 제대로 들어오지 않았을 경우에 다시 시도(다음 프레임)
					해당 내용들이 제대로 들어왔을경우 체인큐에 다음 chain 등록
			Init
				본인 안에 있는 db 와 썸네일,하우스 db 로 자신의 데이터를 초기화
				기타 초기화 해야할 내용들 넣기(주로 초기화 했어야하는 내용들로)
					userprocessor
						chainList
					stuffprocessor
					uiprocessor 
			ExecuteProcessor
				내부에 실행시켜야할 전략을 실행시킨다
					BuildStuffs
						하우스 db 에서 루트 정보를 들고온다.
							빌드비지터를 만든다.
							비지터에 루트를 넣는다.
							
							
					
				
시발 시리얼라이즈 해야하네...흠...
	그럼 음...DFS로 탐색을 하면서 
어떤 물체(노드와 연결되어있음)
아이디어
	깊이 맵으로 물체의 수직인 방향의 높이를 잰다.
		높이를 재고나서 만약 특정 정점이 입력이 되었다면 해당 정점에 기록을 해준다.
			어차피 하나의 버택스에 대해서만 기록을 하기때문에 그렇다.
		그렇게 기록이 되어진 depthMap 과 다시 정점들을 체크해서 
	그렇게 높이를 잰 공간에 대해서 해당 정점들만들 찾는다.

#housing
	+ 방 구조는 선택시 변경 불가능
		+ 원룸일지 복층일지
			+ !해당부분은 상의가 필요함. 예를 들어서 복층인데 반층이 올라간 복층일지 풀복층일지
			+ 어쨌거나 한 노드에 컴포지트가 여러개는 맞다. 
				+ 왜 상속구조를 액터에 붙여놓지 않고 나눠놨는가.
					+ 변화에 대한 업데이트나 컨트롤이 쉽게 하기 위해서 구조를 나눠놓음
					+ 그렇다면 액터에서 scene 으로 자식구조를 만들고 나서 개별로 업데이트 하면 안되는 거였나?
						+ 이것도 맞는말이다. 이게 더 게임 구조에 긴밀하게 연결되어있을거같은데
					+ 틱의 업데이트오버헤드를 줄이기 위해서 그랬다. 무엇보다 언리얼에서 scene 액터에 무언가를 추가하고 변경하는 것은 쉽게 되지는 않는데 이게 더 나을거같다. 음...
					+ 그렇다면 모든노드들은 정보를 담고있고, 그 정보를 생성시에만 하게 하고 모든 노드의 수와 인덱스를 관리하는게 필요하다.
						+ 어디서 관리할것인가? 가장 좋은것은 pak 에서 포인터들만 저장을 해놓고 있다가 업데이트 하는방식을 사용하자. 
							+ weak 포인터로 관리하게 된다면 lock 을 걸어줘야한다. 

builder

chainBuilder
	
먼저 구현해야할것
백터를 자식으로 가진다면
TemplateInterface
	Add{t}By{AddType}
		Add{}ByPtr(t*)
		Add{}BySmartPtr(TSharedPtr<t>)
		Add{}ByNewPtr()
		Add{}ByNewPtrWithParam(t에따라달라짐)
	Insert{t}By{InsertType} : opt 1
		Insert{}FrontByPtrWithIndex(t,int32)
		Insert{}BackByPtrWithIndex;
		Insert{}FrontByNewPtr()
		Insert{}BackByNewPtr();
		Insert{}FrontByNewPtrParam(t에따라달라짐)
		Insert{}BackByNewPtrParam(t에따라달라짐)
	Insert{t}ByPtrWithIndex : 반드시 정말 반드시 설정을 해야한다. 기본은 front
		
	Remove{}By{DeleteType}
		Remove{}ByIndex(int32)
		Remove{}ByTagFirst(FName)
		Remove{}ByTagWhole(FName)
		Remove{}ByTagContactOrder(Fname,int32 order)
	Search{}ByTag

노드니깐 위의 것들하고
	localPath
	RemotePath
	ParentNode
	ChildNodes

포인터를 제거하고 하나만 남기는기능
	최적화를 위해서
#구현구조
siteNode
	Thumbnail
	
클래스 내부에 있어야하는것들
var HosingPakProcessor
	var StuffProcessor
		var SiteRoot
		var CurSiteRootIndex

var stuff
	var LinkComponent
	var state
	
	var node
L		var FTIHState
			var semantic :unsigned long
			func GetState(){return sematic;)
L		var nodeType || tag(tag 일경우에는 uobject꺼사용)
R		var PrivateTag
L		var nodePositionX,Y 노드 그래프내에서 가지는 위치
L		var ParentNode
L		var ParentNodeId
R		var WorldTransform : 월드변환만을 가지고 계층구조는 여기서 가질것이기때문에 
		var CompositeNodes
		var FTIHPathInfo
		var LinkComponent
		
		func PrepareNode : 외부의 데이터를 불러오는 과정(보통 자신의 최상단에서 모든 데이터를 어디엔가 저장한걸 들고오는것)
		func InitiateNode : 가지고 있는 데이터를 가지고 생성해야하는 것들 생성
		func ResetNode : Init 에서 분리된건데, 새로 생성하진 않고 prepare 단계의 값을 들고온다 측 값 초기화
v		func ExecuteNode : 생성되어진 녀석들 가지고 그 녀석들이 해야할 일을 작동
		func UpdateNodeForLocal : 값을 새로 갱신한다. 갱신이라 새로운 값을 업데이트 여기서 한다
		func UpdateNodeForServer
		func GenerateStuff
		
	class FTIHPathData
			var ControlledPlace
				Remote
				Local
			var LocalPath		: 내부에 참조되야할때 사용될 변수
			var RemotePath		: 외부에 저장할 위치 url 
			
			func GetCurrPath
			func GetRemotePath
			func GetLocalPath
			func GetContolledPlace
		
	class LinkComponent
		var Stuff
		var Node
		func virtual CheckUpdate
		func virtual UpdateStuffToNode
		func virtual UpdateNodeToStuff
		
		func virtual CreateStuff
		func virtual UpdateStuff
			for(CompositeNode : CompositeNodes)
				
	class Composite 노드들을 가지고 레이어를 가지는 모음
		var RelativeTransform
		var OwnerNode
		var ChildNodes
		var Layer
		
		func GetLayerUpVector() : ftransform 과 upVector 를 곱해서 만든다.
	class Layer : 추상화? 추상화 하자. 뭐 얼마나 떨어지겠어
		var OwnerComposite
		var Vec2Bound
		var Priority
		ver tarray<polygons>
			polygon
				Halfvec3 xyz 6byte
				Halfvec3 xyz 6byte
				Halfvec3 xyz 6byte
				
									18byte
									
				
		
		func virtual IsInThisLayer(MousePointer)
			
		func virtual InitLayer
		func virtual CalculateLayer
		func virtual AddNode() : 이걸 콜하면 자신의 
		func virtual GetAreaEdge	
			
	var LayerQuad :: Layer


class FTIHHouseStuffProcessor : native
	
	
class ATIHHouseStuff : ueactor
	int32 indexWithinStuffProcessor
		자신이 위치한 인덱스의 위치이다.
	
class FTIHHouseNode : native

기존
	actor <- node : 노드가 액터를 개별구조로 만들고 stuff 의 구조를 단순화 시켜만드는 즉 노드는 builder 에 가까움
	actor -> node : 그저 세이브 로드로만 존재하게 만든다.
	
	return 이 꼭 필요한 경우가 아닐경우에는
	
	
유저가 들어오면
	팩이 로딩
		준비단계에서 유저정보 들고온다
			유저정보에는 유저의 노드목록
			유저의 가능한 stuff 목록
			노드리스트를 들고옴
				리스트화 되어진 노드에는
					노드 프로토콜
						프로토콜을 보고나서 static_cast 로 노드화
						노드 프로토콜에서 노드 정보들을 들고옴
						stuff 도 들고옴.
						transform  정보는 어디에 있어야할까
						저거 리스트를 만들어서 모두 저장해놓고 노드는 참조를 통해 object 를 만드는 용도임.
						그럼 blackBoard 가 있어야겠네
						그 black보드를 prepare 하는거지

노드에 들어가야할 정보!!!
	프로토콜
		무슨프로토콜인지
		옵션
			참조할 stuff목록의 인덱스
노드 프로토콜
	노드타입
		
	처리방법
		AsyncType :
			Async
				tick
					반드시 틱별 실행에 대한 함수가 정의 되어있어야한다.
				task
				uswerWait
			Directly
			Automation



노드 디스크립터 배열
0에서 부터 읽어들임. 해당노드는 부지노드임. 비지터가 해당노드의 프로토콜을 읽는다. 참고로 이러한 노드들은 노드 리스트에 들어가있으며 노드리스트


노드를 읽으면 그에 따른 계층을 구성해줬으면 좋겠는데, 흠...노드가 진짜 경량의 구조로 된다 생각하자.
그럼 일단 스터프와 매터부터 만들고, 그녀석이 배치되고 나서 클릭을 구현하자
클릭을 구현하고 나면 레이어를 노드가 아니라 스터프에 넣도록하자. layer 는 scene 컴포넌트로 해야하나?
아니다 그냥 개별로 존재하게 하고 레이어는 오브젝트의 인덱스를 저장하는걸로 가자.

컬링 바운딩 박스를 만들고싶다면
	먼저 월드로 변환이 된것을 다시 중심이 되고싶은 물체(o)의 월드변환한 것에 대한 역행렬을 구한다. 그리고 그 월드로 변경을 하고싶은 물체(t)의 월드 행렬에 곱해주면 변경하고싶은 물체는 원점이 되고싶은 물체에 위치하게 된다.
		그렇지만 o 라는 물체는 그냥 로컬월드 라고 생각하면 되고, t 만 해당 월드로 간 결과가 나올것이다. 즉 로컬->공통공간(이경우 월드)->특수공간으로 변환이
			이는 카메라 변환과 같다.
	하여튼 이렇게 구해진 t 의 안에 o 의 버텍스가 포함이 되는지를 계산하면 된다. 계산 방법은 t 의 lfd(wid dep hei) 를 축으로 하고 해당 점과의 거리나 뭐 영역안에 잇는지 검사하면 된다. 진짜 간단하게 AABB 적용해도 되기는하는데, 그냥 점과 내적으로 해결해도 괜찮음 아니면 면의 방정식사용하든가
# Enhanced Input System
인핸스 인풋 디버그
	` 키입력 showdebug enhanced input 입력
	런타임으로 인풋을 변경할 수 있다.
	우선순위를 설정 할 수 있다.
		매핑 컨텍스트를 추가해서 월드를 알지 않고 그냥 우선순위를 지정할 수 잇따.
	수정자
		수정자를 사용해서 원시입력을 받고 필터링 할 수 있다.
	트리거 스테이트
		트리거 혹은 인풋액션(ia) 는 그자체로 입력행동이다. 말그대로 힐링 이라고 되어있다면 그 안에 지금 해당 상태가 어떤것인지 혹은 바인딩되어진 입력은 무엇인지 이다.
			즉 액션이 객체화 되어진것이 ia 인것이다. 행동은 따로 있고, 만약 힐링이라는 것이 키보드 A 키, 마우스 dpi 키, 조이스틱 X 키 이런식으로 되어있고 해당 기능은 특정 함수에 연결되어있는것이다.
	입력 리스너
		블루프린터에서 특히 더 보기 편한데, 입력을 바인딜하는 것을 말한다. triggered,started 같은것에 함수를 바인딩하는것을 말한다.
	입력 매핑 컨텍스트
		각 행동에 물리적 키를 매핑하고 해당 매핑일때 일어날 트리거나 입력 모디파이어를 변경하는것을 계층적으로 보여주는 것이다. 여기서 여러 입력의 우선순위를 지정한다.
	입력 모디파이어
		입력 모디파이어는 입력 트리거로 보내기전에 들어온 값을 변경하는 기능이다.
## 상세
	IA 는 해당 기능을 담고있는 기능을 뜻한다. 힐링,공격,움직임,빌드 같은 기능이다. 그래서 해당 기능에 키를 매핑하는게 아니라 함수를 바인딩하는것이다.
	키바인딩은 입력 매핑 컨텍스트로 한다. 
### 좌표값을 얻어 월드좌표화 하는방법
	+ GetController<> 컨트롤러를 얻어온다.
	+ GetMousePosition 마우스포지션을 컨트롤러로 부터 얻어온다
	+ DeprojectScreenPositionToWorld 컨트롤러로 부터 스크린스페이스의 포지션으로부터 월드 좌표를 얻어온다.
	+ FCollisionQueryParams 를 만들고 ignore 를 설정해준다
	+ GetWorld()->LineTraceSingleByChannel 를 통해서 rayTracing 을 해준다.
	+ 그리고 나온 FHitResult 에서 Actor 를 가져와준다.
### 입력 매핑 컨텍스트 셋팅방법
	+ GetController<> 컨트롤러를 얻어온다.
	+ localPlayer 를 가져와준다.
	+ UEnhancedInputLocalPlayerSubsystem 을 로컬플레이어로 부터 가져와준다.
	+ inputLocalSubSystem->AddMappingContext(mInputMapping.LoadSynchronous(), 1); 를 호출해서 매핑해준다.
### 입력 액션
	+ UInputMappingContext 를 만들어준다.
	+ UInputMappingContext 를 설정하고 Binding 해주면 된다.
	+ UEnhancedInputComponent 를 SetupPlayerInputComponent 의 PlayerInputComponent 를 캐스팅해서 얻어와준다.
	+ PlayerInputComponent에서 bindAction 을 해주고, 해당 액션에 IA 를 넣어준다.
	+ callback 함수는 const FInputActionInstance& Instance 를 인자로 가진다.

작업내용
playercontroller 를 기준으로 한다.
	possess 는 pawn 에서 바인딩해준다. 
enhanced input system
	이거 완료했다라고 넘어가자. 어차피 여러가지 바인드 만들어서 넣어주고, 그걸 연결해야한다
	디버그 시에는 그냥 기존 레거시를 사용하자.
플레이어 컨트롤러에 uplayer 가 있다. 그러므로 변환과정을 생략할 수 잇다. GetController 는 템플릿버전으로 있다. 그거는 cast 가 포함되어있다. 이걸사용하자. 
마우스 포지션을 불러오는것을 여러번 할거같은데 이걸 저장하는게 좋지 않을까 싶다. 아니면 공통으로 저장한곳이 있고, 그걸 호출하면 만약 지금 프레임이 같은 프레임이면(이정보를 저장해야한다)
물체의 결과에 대한 world 위치는 그냥 월드로 넘기는 코드를 만들자. 그럼 특정 액터를 필터하고 해당 물체를 필터하는건 해당 pawn 일때만 하자. 
	그러고 나서 해당 물체를 클릭했을때 해당 물체만 들고오게 하고, 위치에 따라 어떤 레이어 위에 있는지로 검사하자.
마우스로 물체 드레그
	해당 기능은 마우스 클릭이 일어났을때 발생한다. 마우스 버튼 다운은 모두 동일 할 것인데, buildPawn 에 지정되어진 정보는 다를 것이다. 무엇보다 pawn 과 widget 은 서로 다르게 정보를 들고오기때문에
하우스
	하우징 구조를 유지해야한다. 그말인 즉슨 pak 이 지워진다고 사라지는건 안된다. 그럼 음...pak 안에 물체를 저장해야할텐데 그러면 이걸 스테이션에 저장?!
	아니면 dontDestroy
station
	서버 접속을 하는 코드를 만든다
	pak 을 가진다
	유지해야하는 오브젝트의 디스크립션 혹은 생성 구조를 가진다.
	유저의 orange정보
	접속 위치 정보
	내부 정보
	
	결론 : 다양한 정보를 가지고 있고 하드웨어적인 동작을 여기서 한다.
	
	pak
		각 기능에 대한 정보를 담고있다. 
		pak 내부 전용 오브젝트 풀 관리자 -> 메모리 관리라기 보다는 오브젝트 풀링과 관련된거임.
		
		그러면 데이터 사이클도 필요하다. 시작점과 끝점이 같아야한다라는 생각은 하지말자.
			만약 local 에서 만들고 global 로 옮긴다. 흠...pakCache 에서 stationCache 로 옮긴다. 
# 함수 규칙
Prepare			:	
	준비하는 것이다. 예를 들자면 외부 confi 를 가져와서 뭐 서버 url 이라든지 해당 클래스를 미리 정의해놓고 가져오는것이다. 즉 환경설정을 미리가져오는 곳
Init
	만들어야 하는 것들을 만드는 곳이다. 내부에 포인터가 있다면 prepare 에서 가져온걸 가지고 만든다.
Execute
	실행하는 곳이다. 명시적으로 init 다음이여야한다. 초기화 플레그가 없다면 실행 assert 가 발생
Refresh
	init 와 비슷하지만 refresh 를 가지지 않는 것들 중 유지해야하는 녀석들은 냅둔다. 구현의 후순위가 될것이다.
Wait
	execute 의 반대임. 기다림이 필요할경우에 사용한다. 구현의 후순위
Clearance
	정리에 사용되는 것으로 연결을 끝지만 삭제는 안해야할 때 사용한다. 어찌보며 ㄴrefresh 안에서 실행될듯
Destroy
	진짜 삭제용. 구현의 우선순위
Connect & DisConnect
	서버에 접속할때 사용하는 것이다. 어차피 접속을 해야 서버기때문에 start 를 대체한다.
	접속 종료를 선언할때도 사용된다. 즉 종료만 하는것이다. 초기화는 하지 않는다.
Check
	서버의 상태를 확인할때 사용한다.
	혹은 무결성 검사때 사용한다.
Request & Receive

네트워크는 station 에 저장되어있음.
시스템 파츠는 uobject 도 있겠지만 우선은 없다는 것을 가정함
내부에 있는 파츠들은 전부 memorySystem 에 달려있음.
	오브젝트 풀링도 가능하며 미리 공간을 할당함
		pakCache 와 stationCache 가 따로 있음
			서로 영역을 왔다갔다 할 수 있음.
			호출을 어디서 했는지도 확인할 수 있는 코드가 필요하다
class FTIHState;
	상태를 가지고 있다. 굉장히 미니멀하게 만들생각이다. 일반적이어야한다.
		
		blocked	:	대기상태이다. 즉 오브젝트 풀안에서 아무것도 할당되지 않은 상태
			ready	:	예약상태,즉 할당은 되어진상태 이때 running 으로 넘어가기 전의 상태이다. 코드로 생각하자면 할당이 되었을때 사용한다.  
				intro : ready 에서 running 으로 가는 명령어이다. 해당 명령이 떨어지면 해당 오브젝트의 작동을 한다.
		running	:	동작을 하고있다
			wait	:	동작을 하는데 대기상태이다. 주로 sync 작업에 사용된다. 여전히 실행이 되어야하는데 기다리는것
			stop	:	running 에서 treminated 로 넘어가기 전에 wait 이 걸린것들을 종료하기 위해 만든 임시상태. 실행상태를 종료하기 위한 실행상태 작업할당의 마지막
		terminated : 여기에 관련된 작업들을 멈추는 일을 한다. 
			break	:	다시 block 으로 돌아간다
			Destroy : 아예 종료를 시켜버린다.
		
		preparation == blocked
		Initiation == ready
		Starting == intro
		Execution == running
		Waiting == wait
		Stop == stop
		Clearance == terminated
		Refresh == break
		Destroy == Destroy
	
		생성
			생성과 관련해서는 외부의 무언가를 들고와 사전준비를 하는 단계와 초기화를 나눈건 잘한거같다.
		실행
			실행에서 계속 실행(tickable)과 종료가 예정된걸 잘 나눈거 같다. 그리고 해당부분이 나뉘어야 비동기가 가능해진다.
		재사용
			여기가 좀걸리는데, clearance 를 만든이유는 종료를 위하기전에 정리하는 단계로 만든것이다. 초기화를 하는 단계인데, refresh 와 좀성격이 다른건 정리를 하지만 지금의 내용을 삭제하는 것이 주된 이유다.
			특히나 터미널의 경우에는 삭제를 위한 단계인데, stop 을 만들어서 clearance 와 실행의 중간단계를 만들어 undo 하는게 가능하도록 한것이다.
			
			
		삭제
			이걸 열어야하나 일단 정리-삭제 혹은 정리-초기화, 정리-재시작 이런느낌인데, 
			정리삭제 : Destroy
			정리재시작: Refresh
			그러면 terminate.Destory 상태면 임시상태고 해당 녀석을 삭제한다
			refresh 의 경우에는 지금 내가 가지고있는것을 그냥 초기화하고 다시 시작하는 느낌이고
			clearance 는 그냥 정리로 통일하자. 
			stop 은 지금 상태를 가지고 
			stop 은 running 의 것들을 전부 멈추게 하는 것
			clearance 는 
			
		created
			preparation == blocked
			Initiation == ready
		Ready 
			Initiation == ready
			Starting == intro
		Running
			Execution == running
			Waiting == wait
		blocked
			Stop == stop
			Refresh == break
		terminate
			Stop == stop
			Clearance == terminated
			
		
		blocked
			스테이션에서는 이제 막 생성되어진 상태일때다. 이때 prepare를 실행시킨다.
			팩에서는 이제 막 만들어진 상태이고 prepare 를 실행시킨다.
			
			
		생성	:	
			Created
		준비	:	Ready
			prepare : 외부나 사전준비에 해당
			Init : 실제로 만들어야하는 것들을 여기서 생성해줌.
		실행
			Execute
			Wait
		종료
			Refresh
				초기화 하고 재 할당하는게 아니라 처음값으로 돌리는거
			Clearance
				초기화 하고 뭐 할당된게 있다면 지우지만 매니저
			Destroy
				초기화 안하고 그냥 지워버리는거
		
			
enum ETIHMainState : char
{
	NotUse = 0,
	Create = 1,
	Prepare,
	Init,
	Execute,
	Wait,
	Refresh,
	Clearance,
	Destroy,
	StateLength
};
			

만약 유니온 구조체에서 자료를 넣게 된다면 리틀빅구조에 의해서 꼬여서 들어가게 된다.
	해결방법은?
		아예 구조자체를 소팅하는 방법을 아는방법밖에 없다
			
enum	ETIHAsyncType

enum	ETIHMainState
union	FUnionTIHStateValue
struct		FTIHStateValueDetail
class	FTIHState
	상태를 담고있고, serialize 
class	FTIHTagWrapper
class	FTIHCommand
class	FTIHCommandList
class	FTIHCommander
class	FTIHPakInfra
class	FTIHManagedObjectComponent
class	FTIHManagedObjectComposite
class	FTIHManagedObject
class	FTIHManagedObjectPool
class	FTIHServerConfigure
class	FTIHServer
class	FTIHNetwork
class	TTIHStationCRTP
class	FTIHStationPolymorphInterface
class	FTIHDefaultStation

커맨더
	프로토콜을 보고 그럼 프로토콜을 읽고 특정 값을 들고오면 되는거지. 그럼 명령을 처리할 데이터덱이 필요하네. 

#하우스 노드 재설계
컨셉은 html 이다. 즉 태그기반으로 만들며 여러 태그가 있을뿐이다.
이를 읽어 들이는 것은 원래는 visitor 였으나 이름이 바꿔도 괜찮다.

그럼 이제 이걸 쓰는건 어떻게 해야할까?
	처음 생각했을때는 xml 을 사용할까 생각했는데, 흠...그니깐 해당 xml 에 해당하는 노드가 있고, 해당 노드는 그냥 해당 작업을 할뿐임.
	예를 들어보자.
	&user.mesh.
	
	명령어 목록을 만들어보자
	stuff 를 만나면 0으로 
		type
		
	
	<stuff layer="quad" cellcount.xy="10,10" path="auto"> 차라리 actor 를 만들고 이걸 xml 화 하는걸 만들까?
		<stuff object.mesh={user.mesh[1]} object.mat={user.mesh[1]} layer="quad" pos.wall="left" >
		<stuff object.mesh={user.mesh[1]} object.mat={user.mesh[1]} layer="quad" pos.wall="back" >
		<stuff object.mesh={user.mesh[1]} object.mat={user.mesh[1]} layer="quad" pos.wall="right">
		<stuff object.mesh={user.mesh[1]} object.mat={user.mesh[1]} layer="quad" pos.wall="front">
		<stuff object.mesh={user.mesh[2]} layer={user.layer[0]} pos.xy="25,0.1" rot.yaw="34">
			<stuff object.mesh>
	정말 좋은데 나중에 만들고 이거랑 비슷하게말이지
	display 와 ui 는 다름 display 는 오브젝트에 가까움.	
		그러면 display 아래에 stuff 가 갈 수 있는가? ㄴㄴ
	Kind {stuff display}
	layer
	data
		object
		ui
	pos
	rot
	int128 로 만들어진 descriptor
	
	create
	
	save
		자기 정보를 다시 descriptor 화
		만약에 서버로 보낼거다.
			특정 계층만 그럼 해당 노드부터 아래로 계층으로 보냄. 노드에 달린 태그를 통해서 못보내는것도 졶재
	stuff actor
		composite
			stuff
				composite
					
				layer
					quad
		layer
	descriptor desc
		
	build
	
	switch (desc.type)
		case stuff:
			CreateStuff(desc.stuffDesc)
				stuff* actor
				if(desc.stuffDesc.layer)
					actor.layer()
						layerRefArray[desc.stuffDesc.layer]
				if(desc.stuffDesc.objectMesh)
					actor.mesh
			
		
	builder.createStuff
		.layerShape(quad)

만약에 이미 task 목록이 전부다 꽉찼다면 -> 서버테스크도 공유이고 무조건 한가지정도는 사용을 한다는의미
	
커맨더
	주요용도
		오브젝트 로드를 하나하나 하는용도
		오브젝트 생성을 하는데 하나하나 하는용도
		
		그러면 
		for(int i = 0; i < TickBaseCount; ++i
			load[i];
		
		if(next 남았는지 확인
			남았다면 command->addCommand(다시 해당내용)
		else
			end callback 이 있다면 콜백 or 넥스트 command->addCommand(다시 넣기)
	
	command
		아니면 종류를 나눠놓을까?
		protocol : 
			load :
				asyncType
					tickable
					task
					
					char AsyncType;					
					char StartIndexWithinShareBoard;
					char EndIndexWithinShareBoard;
					char SplitCount;
					char ErrControl;
					char FuncRef;
					char ChainNext;

			move
				
				
			
			
		123456789
		int64
			union
			{
				struct
				{
					char protocol
					union
					{
						struct FTIH{}Load
						{
							
						}
						struct FTIH{}move
						{
							
						}
						struct FTIH{}기타 생기면
						{
							
						}
						int DataMass56;
						char ByteArray[7]
					}
				}
				int64 DataMass64;
				char ByteArray[8]
			}
			
			
			
이제 함수를 여기에다가 만들어줘야하는데 말이지. 흠...지금 마음이 걸린다. ㅋㅋㅋ
	왜냐하면 성능부분.
		 이부분은 무거운 작업을 나눠서 작업하는데, 편하게 하려고 하는거니깐 넘기고
	안전성부분 은 흠....해당 액터가 삭제 되었는데 그것을 참조하려고할때 블럭을 걸어줄 수 있을까?
		사실 래핑을 할까 생각하는데,어차피 액터를 받아서 사용할거잖아. 예약기능도 만들까?
		
	확장성부분 은 결국 이러면 여러 타입을 만들어야하는데, 아싸리 반환형만 있고 인자는 없게 하는게 맞는걸까 하는 의문이 거대하게 든다.
		
스테이션
	내부에 핵심적인 기능들을 담고있다.
		팩관련
			생성할 팩 prepare
			팩 생성
			팩 동작
			팩관리
		기타 데이터 관련
			커맨더 -> 무거운 작업을 틱
				
			데이터 생성
				오브젝트 풀링->managedObject(삭제후 다른형태로 변경)->이런시팔 언리얼 오브젝트 풀링 만들어야함.
					역할은 오브젝트 풀링을 하는 것과 오브젝트의 외부 메타데이터를 저장하는 용도임
					->이거 쓸모없는거같음. 중요한건 액터든 뭐든 다시 재구성하는게 중요한데, 필요한가?
			오브젝트명세정보 배열 
				관리해야하는 오브젝트는 이렇게 배열로 만드는게 맞다. 근데 흠....
			
		서버 접속
			서버 접속 관리
			서버 데이터 뿌리기

액터
	메쉬
		스태틱메쉬
			자료위치
				로컬
				글로벌
				기타 메타데이터
					파일크기
					lod 수
					버텍스 버퍼크기
					인덱스 버퍼크기
			메테리얼
		스켈레탈메쉬
			자료위치
			메테리얼
		이펙트?
	UI
		유아이는 유아이지
		
		
저장해야하는것
	로컬
	서버
	
	메쉬파일
		버텍스정보들
			pos
			uv
			normal
			...
		인덱스정보
		메타정보
	
	매시인덱스지
		
		저장인덱스
	mat인덱스

메쉬 메타 배열
	메쉬 메타 데이터
		지금 저장되어있는곳 위치
		참조 메테리얼인덱스
		크기
		태그

메테리얼 메타 배열
	메타 데이터
		저장되어있는위치
		참조 텍스처메타정보 인덱스
			텍스처 갯수
			텍스처 위치 배열
				참조
			
노드
	타입
		스터프
			타입
				메쉬
					
지금 노드는 
	타입 스터프
		오브젝트
			스태틱메쉬
				참조할 메쉬인덱스
					파일경로
						위치타입
						저장플래그
					파일크기
					태그
					
노드
	오브젝트타입{스터프,디스플레이}
		레이어정보 
		메쉬
	
유저의 메쉬(전용 메쉬)는 로컬에 저장되지 않고 무조건 서버로 전송된다.즉 플레그가 유저플래그로 설정되어있음
		
	
	구체적으로 메테리얼
		값 파라미터 메타정보 인덱스
			값시작
			값개수
			파라미터
				값이름
				값벨류
		텍스처 파라미터 메타정보 인덱스
			사용된 텍스처 갯수
			텍스처 메타정보
				파일위치
				크기
				타입
				파일 정보
		옵션 메타정보 인덱스
			여기도 나중에
			
규칙
	바로 들어가있는것은 data 라고 표현
	참조할건 index 로 표현

TArray<meshMeta> meshMetas;
FStringBuffer;

FServerConfig
	FserverStringConfi

meshMeta
	path
		char : savePlaceTypeData {local,server}
		char : saveFlagData {userCustom,dontCopy}
		char : replaceOpt {대충대체할메쉬인덱스}
		char : paddingData
		FMetaString :saveStringMetaData
			short : stringIndex
			short : lengthData
	material
		char : matParamMetaIndex
		char : matTexMetaIndex
		char : matOptMetaIndex
		char : padding
	ex)
		path="local,["userCustom","dontCopy"],"
		
metarialMeta
	char : matParamMetaIndex
	char : matTexMetaIndex
	char : matOptMetaIndex
	char : padding
matParamMeta
	paramIndexCount
	startIndex
FTIHPath
	char 


matTexMeta
	
matOptMeta

matParamMeta
matTexMeta
matOptMeta

FMatParameterData
	type
	name
	value


리얼자료 -> 같은 자료만 저장
PathsArray;

개념상 묶어야 하는것일 경우에는 함께?

메타자료 ->인덱스만 저장

savePlaceType
flagIndex
replace
pathIndex


이것도 crtp 로 만들어야함.

FTIHMetaStuff
	StuffType
	MeshIndex
	MeshLength
	FTIHMetaComposite : composite
	
	
FTIHMetaComposite
	CompositeType
	OwnerIndex
	StartIndex
	IndexLength
	

FTIHMetaDisplay
	DisplayType
	
FTIHMetaMesh
	meshType
	MetaPathIndex
	MeshHeader
		size
		vertexCount
		이거는 좀 찾아보자.
		
	materialIndex
	materialLength
	
FTIHMetaMaterial
	materialType

	textureIndex
	TextureLength
	
	paramIndex
	paramLength
	
FTIHMetaTexture
	textureHeader
	textureType
	savePathIndex
	
	LODIndex
	LODLength
	
FTIHMetaParam
	paramType
	paramName
	paramValue
	
FTIHMetaPath
	PathType
	PathStringIndex
	PathStringLength
	

diplayDirector
	
TArray<FTIHMetaStuff>


class AStuff
	refStuffIndex; || FTIHMetaStuff(이경우 직접저장해도 인덱스는 필요)
	
	
void GenerateStuff
	EStuffType rootStuffType = rootStuff.stuffType;
	
	if(rootStuffType == staticMesh)
		builder = CreateStuffStaticMesh<>()
		if(0 < rootStuff.meshIndex)
			for()
				stMesh 
				builder.RegistStaticMesh()
		
	load->set
		로드를 한번에 할까?흠....
		그러면 prepare 
				
		command
			1 정해진 것들에 대한 플래그만 해놓기
				확장성이 줄어듦
				
			
			2 커스텀 가능하게 만들기
				안전성이 떨어짐

여기서 한번 생각을 해보자
	어렵지 않게 가야한다.
	한번에 넣을 수 있는 최대 정보는 결국 int64 임. 그래야 시리얼라이즈가 편함.
	그럼 char 8개인데, short 4개 int 2개임흠...메타데이터는 묶어서 사용해야하는데
	그 int64 를 좀 포기할까? ㅋㅋㅋ
		최대한도 힘듬. 이거 결국 내가 힘들어짐. 그럼 FArchive 이거 최대한 노력해서 써봐야하나
	
이봐. 만약에 struct TempA{
int32 Aa;
int16 Ab;
int16 Ac;
int64 Ad;
}
가 있고
struct TempB{
int32 Ba;
TempA Bb;
}
가 있어. TempB 의 각 변수 주소는 그냥 Ba 를 b0 Bb 를 b1 라고 할게.
그리고 나서 tempA 는 Aa == a0,Ab== a1,Ac == a2,Ad == a3 라고할게.
빈엔디안 일때 주소 저장순서와 리틀 엔디안일때 주소 저장을 알려줘. 



0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
0 1 2 3 4 5 6 7 8 9  a	b  c  d  e  f 10 


결정이 난것들을 정리해보자 오늘 이것만 하자
	하우징 뿐만 아니라 전체적인거
		데이터모음과 메타데이터의 분리
			메타데이터는 데이터모음에 인덱스를 가져올건데 인덱스는 절대 인덱스로 id 와 비슷함. 결국 해쉬값이라고 보면 된다.
			데이터모음에 대한 정리
				데이터 모음은 다른때에도 사용할 수있는게 중요함.
					이걸 처리하는걸 그냥 meta 로 처리. 즉 description View 와 같은거임
					-> 결론적으로 해당 메타데이터만 가지고도 다른곳에 옮겨 처리할 수 있게, 단순 자료형으로 만드는것이 좋다.
						이걸 생각하다보니깐 int64 의 크기를 넘는 것이 부담이 되었는데, 생각해보니 그럴 필요가 없었음.
						메타데이터 계층도 있고 유니온파인드로 확인도 하고 하여튼 메타데이터가 핵심임.
						그런데 이걸 이제 커맨더에도 넣을 수 있어야한다.
			메타데이터만 옮겨서 어떤걸 컨트롤 할 수 있어야한다
				컨트롤이라니깐 좀 이상한데, 해당 데이터를 넣으면 해당 데이터를 통해서 무언가를 컨트롤 할 수 있는것이다.
				`여기에서 분기
					`` 커맨더 와 메타데이터를 같이 넣는 구조로 일반화
						장점 : 쉽다. 일반화해서 커맨터와 메타데이터만 만들면된다 즉 일관성이 있다.
						단점 : 
					`` 커맨더 따로 메타데이터 따로로 같이 넣을때도 있고 하나만 넣을 때도 있게 만들것인지.
						장점 : 확장성
						단점 : 어렵다,복잡하다,일관성이 떨어진다
					-> 결론 : 구조는 커맨더와 메타데이터를 무조건 같이 넣는 것으로 만들되 그게 필수조건은 아니게 하면 된다. 커맨더 중에 커맨더처리를 안하게 해도 되는거아님?
				하여튼 장점으로는 해당 데이터만 보내면 다른 곳에서 컨트롤 할 때도 좋고, 반응을 관리하는 관리하는 곳이 생기는 것이다.
				그래서 해당 구조로갈거다
					메타데이터와 커맨더
					메타데이터는 무조건 wrapper 에 감싸져 있을것이고, 해당 데이터는 수정이 가해질것이다. 그럼 wrapp
				`여기 장애물과 고려할점
					`` 일반화를 어떻게 할것인가. 상속으로 만드는 선택지는 좋지 않다. 참조로 만드는 것도 좋지않다.
						-> wrapper 를 만드는게 가장 좋다. crtp 를 사용하는건데 이건 생산성이 떨어진다
						일단 메타데이터 자체가 serialize 화 될수 있어야하고, 가벼워야한다.->데이터를 옮기는데 있어서 포인터를 가지지 않아야하고 새롭게 생성되더라도 그리 크지 않아야한다.
							그러면 자체가 serialize 화 되는건 프로그래머에게 맡기자. 하지만 흠....규격화 해야할텐데 메크로로 가자.
					staticPolymorph 로 하지만 여기서 중요한건 이게 무슨 타입인지 확인하는것이다.
						즉 해당 자료에 공통으로 확인할 영역이 필요하다. 그럼 해당 메타데이터에서 공통으로 추출할수있는 정보로 체크해야한다.
							그럼 구조는 단순하다
							커맨더도 마찬가지고 메타데이터도 마찬가지이다. header == Int64 로 만들자.이게 최소 4글자보다는 나은거같다.
							커맨더와 메타를 동시에 포함해야하니깐
							이거는 union 으로 만들자
			메쉬를 구성할때 로드-actor 셋이필요하다
			ex)
				하우징 팩의 prepare 에서 command 로 
					FTIHCommand
						protocol 
							main {Create,Modify,Insert,Delete,Server,StaticCustom0,StaticCustom1,StaticCustom2,StaticCustom3,DynamicCustom}
							sub {}
							argu {}
							opt {}
							
							Create
								.Load
								.Alloc
							Modify
								.Transform
								.Update
							Delete
								.Check
								.Range
								.List
							Server
								.Connect
								.Request
								.Receive
								.Disconnect
						CommandAction
							BlockType {Through , Async }
							asyncType {}
							
							
					protocol : ui생성,nonBlock,타겟-하우징처음로딩씬, 요청정보-없음,실행함수,완료시함수,에러시함수 ->이경우에 삭제되지 않는다면  계속 존재할거임
						Create.UI,
					protocol : 서버접속,block,타겟-dataServer,요청정보-receiveHousingData,실행함수,완료시함수,에러시함수
					
				를 등록한다.
			이거 일단 커맨더가 할수 있는 것들부터 써야겠다. 커맨더란 무엇인가!
				어떤 기능을 실행시켜줄 녀석이다. 어떤기능이냐! 일단 알아야하는건 서버가 주는 정보는 절대적이라는 것이다.
					생성		: 은 물체를 생성할때 사용한다. 예를들어 ui 를 생성하거나 특정 물체를 생성할때 사용한다
					변경		: 은 타겟 물체를 변경할때 사용한다. 특히 움직임에 사용한다.
					삽입		: 은 사실 변경과 같은건데 이거는 뭐 나중에 생각하자
					삭제		: 은 말그대로 삭제를 위한것. 삭제인데 오브젝트 풀에 해당하면 삭제되는건 아니다.
					서버		: 말그대로 서버와 관련된것임	
	스테이션
		서버접속 추상화
		메모리 할당
		crtp
		
				
				