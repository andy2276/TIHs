# 고민하는거
+ 지금 GPU 처럼 명령을 나누고 실행하는건데, 이걸 한 이유가 tickable 이나 multiThreading 을 위해서 만든것인데, 커맨드가 너무 일반화 되지 않은것 같다.
	+ 그렇지만 이미 여기까지 왔고, 이 방법이외에는 구조를 일반화 시킬 수 가 없다. 실행에 대한 순서를 컨트롤 하는데 있어서 이거보다 좋은 방법은 없다. 예를 들어서 ㄱ와 ㄴ 이라는 순서의 서버가 있다면 ㄱ 을 만들고 ㄴ 을 만드는게 맞고 그걸 코드의 구조만 바꿈으로써 변경시키는게 맞기때문에 이런구조를 취한것이다. 뿐만아니라 이동에 관한것도 마찬가지다. 예를 들어서 어떤 영역을 복사한다고 치자. 그 복사한 영역에 대한 내용을 저장해놓고 그걸 커맨드로 만들면 내가 위치만 지정해도 문제 없이 들어가는데, 이걸 구지 내가 컨트롤 해야하는가이다. 
	+ 지금 이 문제들은 shareBoard 를 제대로 쓰지 않기때문에 그렇다. 일단 이것에 대한 center 를 만들자.
		+ 이거 변경함. 뭐냐면 완전 원시구조보다는 전용 구조를 만들거임. 그니깐 무슨말이냐면 meshpool 은 commandload 시에 저장할 공간을 정하는 곳이고, objectPool 은 commandCreatAlloc 에 대응하는 곳인것처럼 경로만을 저장하는 전용 자료구조를 만들고, 움직임에 관한 것을 저장하는 전용 자료구조
+ 다시생각해보자
	+ 목적이 뭐냐?
		+ 커맨드에서 path 를 호출했을때 영역
	+ 전용 자료구조가 필요한가?
		+ 나는 필요하다고 생각은 하는데, 
	+ 이걸 어디에 쓸거냐?
		+ 메쉬를 prepare 할때 path 로하는데, 이거에서 사용할거임.
## 해야할거
### modify
#### mesh
FTIHCommandModifyConfigure
+ 준비해야할것들을 미리준비하는곳
FTIHCommandModifyPrepareMesh
+ 
FTIHCommandModifyLoadMesh
+ 로드를 했잖아. 그럼 그걸 어떻게 들고오는가? 그건 스스로 액터가 가지고 있을거임. 그게 들고오는거임.
##### 복수
FTIHCommandModifyPrepareMeshes == 한번에하는거임
FTIHCommandModifyLoadMeshes == tickable
	이것의 결과는 이제 메쉬풀에 있을거임. 즉 매쉬는 메모리에 올라가 있는 상태임. - 커맨더를 하나 만들어야함.
	스트라테지도 만들어야함.
### create
FTIHCommandCreateNewAllocConfig
FTIHCommandCreateNewAllocPrepare
FTIHCommandCreateNewAllocOnGenerate
	이제 여기서 액터가 있어야함

FTIHCommandMngObjPooling
	풀링이 일어나면 액터의 특정 함수를 실행할거임. 이거는 언리얼에 잇는거고, 그게 커맨더에 set을 일으켜줄거임.
FTIHCommandMngObjReject


매쉬를 로드하고 액터를 배치하기 위한 순서
SetMeshPoolConfig - CmdCreatePoolingMeshPreparePath - CmdCreatePoolingMeshLoad(여기에 뭐를 위해서인지 자료를 넣어놓자.) - 
CmdNewAllocMngObjPoolConfig - CmdCreateNewAllocPrepareData - CmdCreatePooling

## 구조화 계획
1. 필요한 컨셉 써보기 ==  Concept
2. 뇌코딩 == LogicWrite
	1. 전체적인 방법을 먼저 생각 == Method
	2. 큰범위부터 쪼개기 == splitCategory
	3. 작은범위로 쪼개 들어가기 == splitUnit
3. 검증 == LogicTest
4. 코딩 == Coding

1. 요구사항 분석 
2. 설계
	1. 컨셉
	2. 모듈화
		1. 컨셉에 가까운 범위
		2. 실제 로직에 가까운범위
3. 검증
4. 구현

1. Requirement Analysis
2. Design
	1. Conceptual Design
	2. Modularization
		1. High-level Design
		2. low-level Routine
3. Validation
4. Implementation