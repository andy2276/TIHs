# 고민하는거
+ 지금 GPU 처럼 명령을 나누고 실행하는건데, 이걸 한 이유가 tickable 이나 multiThreading 을 위해서 만든것인데, 커맨드가 너무 일반화 되지 않은것 같다.
	+ 그렇지만 이미 여기까지 왔고, 이 방법이외에는 구조를 일반화 시킬 수 가 없다. 실행에 대한 순서를 컨트롤 하는데 있어서 이거보다 좋은 방법은 없다. 예를 들어서 ㄱ와 ㄴ 이라는 순서의 서버가 있다면 ㄱ 을 만들고 ㄴ 을 만드는게 맞고 그걸 코드의 구조만 바꿈으로써 변경시키는게 맞기때문에 이런구조를 취한것이다. 뿐만아니라 이동에 관한것도 마찬가지다. 예를 들어서 어떤 영역을 복사한다고 치자. 그 복사한 영역에 대한 내용을 저장해놓고 그걸 커맨드로 만들면 내가 위치만 지정해도 문제 없이 들어가는데, 이걸 구지 내가 컨트롤 해야하는가이다. 
	+ 지금 이 문제들은 shareBoard 를 제대로 쓰지 않기때문에 그렇다. 일단 이것에 대한 center 를 만들자.
		+ 이거 변경함. 뭐냐면 완전 원시구조보다는 전용 구조를 만들거임. 그니깐 무슨말이냐면 meshpool 은 commandload 시에 저장할 공간을 정하는 곳이고, objectPool 은 commandCreatAlloc 에 대응하는 곳인것처럼 경로만을 저장하는 전용 자료구조를 만들고, 움직임에 관한 것을 저장하는 전용 자료구조
+ 다시생각해보자
	+ 목적이 뭐냐?
		+ 커맨드에서 path 를 호출했을때 영역
	+ 전용 자료구조가 필요한가?
		+ 나는 필요하다고 생각은 하는데, 
	+ 이걸 어디에 쓸거냐?
		+ 메쉬를 prepare 할때 path 로하는데, 이거에서 사용할거임.
## 해야할거
### modify
#### mesh
FTIHCommandModifyConfigure
+ 준비해야할것들을 미리준비하는곳
FTIHCommandModifyPrepareMesh
+ 
FTIHCommandModifyLoadMesh
+ 로드를 했잖아. 그럼 그걸 어떻게 들고오는가? 그건 스스로 액터가 가지고 있을거임. 그게 들고오는거임.
##### 복수
FTIHCommandModifyPrepareMeshes == 한번에하는거임
FTIHCommandModifyLoadMeshes == tickable
	이것의 결과는 이제 메쉬풀에 있을거임. 즉 매쉬는 메모리에 올라가 있는 상태임. - 커맨더를 하나 만들어야함.
	스트라테지도 만들어야함.
### create
FTIHCommandCreateNewAllocConfig
FTIHCommandCreateNewAllocPrepare
FTIHCommandCreateNewAllocOnGenerate
	이제 여기서 액터가 있어야함

FTIHCommandMngObjPooling
	풀링이 일어나면 액터의 특정 함수를 실행할거임. 이거는 언리얼에 잇는거고, 그게 커맨더에 set을 일으켜줄거임.
FTIHCommandMngObjReject