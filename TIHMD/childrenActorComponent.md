## 이걸 폐기하는이유
1. 액터와 childactorcomponent 는 생각보다 견고하다.
	+ 그래서 이걸 계속 만드는것은 복잡성만 증가하고 안정성은 떨어진다.
	+ 견고하다는것은 해당 기능을 중점으로 만들어진게 많다는 것이고 해당 기능을 넣기에는 
	+ friend 부터 시작해서 너무 많은 엔진 코드를 바꾸게 된다.
	+ 뿐만아니라 해당 기능을 지원하기 위한 함수또한 많다.
	+ 그래서 일반적인 방법으로 이것을 만들 수 없다.
	+ 무엇보다 actor 에게 부모에 대한 정보를 주는게 없다. 모두 childActorComponent 를 전재로한다.
2. 이 모든것을 고려하고도 만들려고 하고도 얻는 이점이 적다.
	+ 내가 이걸 만들려는 이유는
		1. 팩토리에서 만들어줄때 해당 컴포넌트를 보고 해당 컴포넌트에 맞게끔 leaf 들을 구성한다.
			그럴때 childActor 가 많다면 이루어지지 않는다.
		2. 오브젝프 풀링을 할때 한 물체에 childActor 들의 수를 컨트롤하기 힘들다.
			예를 들어서 지금 어떤 물체위에 계층적으로 100개의 물체가 있다고 하자. 이것에 맞는
			물체를 딱맞게 찾을 수도 없을뿐더러 그것도 불가능하다
					
## 그래서 어떻게할거냐?
1. 마찬가지로 컴포넌트로 가지만 내부에 그냥 액터들을 가지고 매니지드 오브젝트의 연결관계를믿는것
	1. 더 정확하게는 어떤 액터가 요청을 하면 그냥 매니지드 오브젝트들중 자신의 액터와 같은 녀석들을 호출
	2. 그 컴포넌트 전용 리프는 연결관계들에대한 명령을 내릴수있게 만든다.
	3. 연관관계는 해당 컴포넌트에서 다른 컴포넌트로 전달이 되는것이다.
	4. 직접적으로 움직이는것이 아닌 물체에 전파하는 것이다.
	5. 액터를 잡고 움직이거나 이걸 카피하면 컴포넌트들에서 들고오는거임.
	6. 즉 언리얼의 움직임 시스템은 쓸수가 없다.<br>이게 문제라 생각했는데, 문제라고 생각하지 않으면 된다.<br>모든 움직임을 이걸로 컨트롤 한다라고 한다면 문제 없음.<br>대신 계층구조 구현하는게 좀 힘들어 질거같긴한데 뭐 시발 괜찮음
		1. 상황1 : 해당 액터를 생성할때
		2. 일단 팩토리를 통해 해당 액터를 일단 생성한다.
		3. 내부에는 스태틱메쉬와 해당 컴포넌트만 있다.
		4. 해당 컴포넌트는 스태틱매쉬의 하위에 존재할것이다.
		5. 해당 컴포넌트의 액터를 움직이면 액터로 움직임이 전달되는것이다.
		6. 해당 컴포넌트에 연결된 매니지드 오브젝트들에게 움직임을 전파. 즉 전체 단계에서 바로 전파 단계로 넘어간다. 어차피 언리얼도 그렇게 하고있음.
## 그래서 해당 컴포넌트는 어떤 기능이 있어야하는가?

+ 복사
	+ 사실 복사는 해당 컴포넌트 안에 있는 내용을 카피하는것이다.
	+ 복사하고 세이브 하는 기능을 만들어야한다.
	+ 복사 하면 해당 내용을 가져와서 재 구축하는것이다.
		1. 복사를 호출하면 클립보드에 생성을 하는 정보를 넣는다.
			1. 정확하게는 그냥 매니지드 오브젝트 포인터만 넣어도 괜찮음
		2. 결국 본체는 다른거임. 
		3. 해당 정보를 붙여넣기 하면 그 정보를 가지고 다시 요청하는거임. 그리고 연관관계는 여기서 처리해주면 된다.
+ 자르기
+ 생성
+ 삭제
+ 검색
+ 전파
+ 링크
+ 언링크
+ 매니지드 오브젝트의 인덱스가 있어야함.
	+ 매니지드 오브젝트 인덱스를 추가 할 수 있어야함.
		+ 이걸 위해서 매니지드 오브젝트를 만들때 해당 액터와 이에 해당하는 리프를 만들어줘야함.
			+ 리프의 기능은 생각
	+ 자신의 매니지드 오브젝트 인덱스를 알아야함
	+ 

## 그걸 위해서 찾은 액터나 컴포넌트의 위치 정보 전파순서

1. 시작은 SetWorldLocation
2. SetRelativeLocation == SetRelativeLocationAndRotation
3. ConditionalUpdateComponentToWorld
4. UpdateComponentToWorld == UpdateComponentToWorldWithParent
5. PropagateTransformUpdate
	1. **if** bTransformChanged
		1. UpdateBounds
		2. OnUpdateTransform
		3. TransformUpdated.Broadcast
		4. MarkRenderTransformDirty
		5. UpdateChildTransforms->physics
		6. UpdateNavigationData
	2. **else**
		1. UpdateBounds
		2. UpdateChildTransforms
		3. MarkRenderTransformDirty
		

